# DBMSの機能

---

## スキーマ

データベースを構成する要素（オブジェクトとも呼ばれる）として主に、データベース、スキーマ、オブジェクト（テーブルやインデックスなど）などがあります。
データベースは複数のスキーマを持ち、スキーマは複数のオブジェクトを持ちます。

スキーマには所有者や書き込み権限などが存在し、権限がないユーザーは、スキーマの中にオブジェクト（テーブルやインデックスなど）を作ることはできません。
スキーマはOSでいうところのフォルダーやディレクトリの役割を持っています。

スキーマの概念はDBMSによっても異なる部分がありますが、MySQLではDBのことを指します。
PostgreSQLでは「CREATE SCHEMA」によりスキーマを明示的に作成できます。
Oracleの場合はユーザー=スキーマと捉えるのが一般的です。

---

## インデックス

インデックス管理はDBMSが持つ機能で、検索を高速化する機能のことです。
インデックス（Index）とは索引のことで、テーブルにインデックスを作成しておくことで、検索処理の高速化を行うことができます。

しかし、インデックスを使用する際に気をつけなければならないことがあります。
それは、インデックスは「使い方次第でパフォーマンスを低下させてしまう」ということです。
頻繁に更新されるテーブルにインデックスを作成した場合、更新されるたびにインデックスも更新されるため、パフォーマンスが低下します。
また、インデックスはテーブルとは別の領域に保存されるため、データベース設計時には、インデックスの保存領域の検討も必要です。

インデックスは、テーブル作成の際にPRIMARY KEY制約、またはUNIQUE制約を付けたカラムに対しては自動的に作成されます。
それ以外のカラムでインデックスを作成する場合は、「CREATE INDEX」の構文で作成できます。

---

インデックス作成の構文は以下になります。

```sql
CREATE INDEX インデックス名 ON テーブル名 (カラム1, …);
```

### 例

studentテーブルのnameカラムに対してインデックスを作成する場合は以下になります。

```sql
-- インデックス作成
CREATE INDEX idx_name ON student (name);
```

インデックスを作成すると、そのカラムによる絞り込みが高速になります。

```sql
-- 検索時にインデックスが使用され、高速になる
SELECT * FROM student
WHERE name = '黒木 れいな';
```

インデックスについての詳細は[インデックス](./DB_10_インデックス.html)を参照ください。

---

## 実行計画

実行契約とは、データのアクセス方法のことで、インデックスにも大きくかかわっています。

インデックスは闇雲に作成すればよいわけではありません。先に述べたように、インデックスは増やしすぎると更新処理のパフォーマンスが低下する可能性があります。

また、インデックスを作成したとしても、検索時にそのインデックスが使用される保証はありません。検索時にインデックスを使用するかしないか、また、使用する場合にどのインデックスを使用するかはDBMSが判断します。
実際に作成したインデックスが使用されるかどうかは、実行計画を確認する必要があります。

実行計画を見るには、実行するSQLの前にEXPLAINを付けます。

```sql
EXPLAIN 
SELECT * FROM student
WHERE name = '黒木 れいな';
```

---

結果は以下のようになります。

PosgreSQLの場合

```text
                       QUERY PLAN
----------------------------------------------------------
 Seq Scan on student  (cost=0.00..15.00 rows=2 width=176)
   Filter: ((name)::text = '黒木 れいな'::text)
```

ここでは実行計画の読み方は割愛しますが、パフォーマンスに問題があるときには実行計画を参照してインデックスの使用の有無などを確認していく必要があることを知っておいてください。

また、実行計画の表示方法や読み方はDBMSによって異なります。

実行計画についての詳細は[実行計画](./DB_11_実行計画.html)を参照ください。

---

## ビュー

ビューとは、仮想的な表のことです。
複雑なSELECT文をビューとして定義しておくことで、SELECT文を簡潔に書くことができます。
また、テーブルの一部のカラムだけに絞り込んでビューとして定義しておくことで、一般のユーザーに不必要なデータを見せないようにすることもできます。

ビューの作成は以下の構文になります。

```sql
-- ビュー作成の構文
CREATE VIEW <VIEW名> AS SELECT文
```

---

### ビューの例

以下のようなitemsテーブルがあるとします。

```sql
SELECT * FROM items;
```

items

|item_id|item_name|price|
|:--|:--|:--|
|1|りんご|120|
|2|みかん|150|
|3|バナナ|300|
|4|ボールペン|300|
|5|ディッシュ|250|
|6|電池|400|
|7|コップ|700|
|8|椅子|2000|
|9|地球儀|5000|

---

このテーブルでpriceが1000以上レコードのみ取得したいとします。
SQLは以下のようになります。

```sql
SELECT * FROM items
WHERE price >= 1000;
```

|item_id|item_name|price|
|:--|:--|:--|
|8|椅子|2000|
|9|地球儀|5000|

これをビューとして定義します。

```sql
CREATE VIEW high_price_items AS
SELECT * FROM items
WHERE price >= 1000;
```

そうすると、以下のSQLでも同じ結果が得られるようになります。

```sql
SELECT * FROM high_price_items
```

---

**ビューの注意点**

ビューを上手に使用すると、複雑なSELECT文を簡潔に書くことができるようになります。
ただし、ビューに対してSELECT文を実行した場合、実際にはビューで定義されたSQL文が実行されているだけなので、速度は速くなりません。
速度が遅いことを解決するためにはビューは使用できないことを知っておきましょう。

また、ビューは仮想的なテーブルであり、実際にデータが存在しているわけではないので、INSERT、UPDATE、DELETEなどの更新処理は基本的にできないので注意しましょう。

※特定の条件を満たせばできる場合もあります。

---

### マテリアライズド・ビュー

ビューはSELECT文であたかもテーブルのように利用できますが、あくまでも仮想的なテーブルであり、ビューにはデータは保持されません。
そのため、ビューを使用してSELECT文を簡潔にしても、データは高速にはなりません。

ビューで処理を高速化する仕組みとして「マテリアライズド・ビュー」と呼ばれる機能もあります。通常のビューとは違って、実際のデータを保持しておくことで、検索の高速化を図ることができます。
ただし、DBMSによって実装されていない場合もあります。

※PostgreSQLには実装されているが、MySQLは8.0時点で実装されていない。

---

マテリアライズド・ビューの構文は以下になります。

```sql
-- マテリアライズド・ビュー作成の構文
CREATE MATERIALIZED VIEW <VIEW名> AS SELECT文
```

先ほどのビューをマテリアルズド・ビューにするには以下のようにします。

```sql
--マテリアライズド・ビューの作成
CREATE MATERIALIZED VIEW mv_items AS
SELECT * FROM item
WHERE price >= 1000;
```

マテリアライズド・ビューを利用すると通常のビューよりも高速なクエリが期待できますが、テーブルに対する更新が即座に反映されるわけではありません。

反映させるためにはリフレッシュを行うことが必要になります。

```sql
-- 中身の確認
SELECT * FROM mv_items;

-- 適当に値を更新
UPDATE items SET price = price * 2;

-- 再度中身の確認 この時点では更新が反映されない
SELECT * FROM mv_items;

-- mv_items をリフレッシュ ここで値が反映される
REFRESH MATERIALIZED VIEW mv_items;

-- 再度中身の確認 ここでは最新の値が取得される
SELECT * FROM mv_items;
```

---

## ストアドプロシージャ

ストアドプロシージャは、SQLの問い合わせをデータベースサーバーに持たせる技術です。
クライアントサーバーシステムにおいては、クライアントからデータベースに対して問い合わせ（SQL文の実行）が頻繁に行われると、ネットワークに負担がかかります。

これを軽減するのがストアドプロシージャです。
ストアドプロシージャはDBMSの機能でデータベースに対する一連の処理をまとめ、データベースに保存したものです。

クライアントから引数を渡してそれに基づいて処理を行ったり、クライアントに処理結果を返したりすることもできます。
データベース内部に保存してあるため、直接データベース内で処理を行うことができ処理速度も上がります。
システム構築を行う上では非常に重宝されます。

---

ストアドプロシージャを使用するメリットは以下の通りです。

* 1つの要求で複数のSQL文を実行できる（ネットワークに対する負荷を軽減できる）
* あらかじめ構文解析や内部中間コードへの変換を済ませておけるため、処理時間が軽減される。
* トリガー（特定の動作に反応して自動的に実行される操作）と組み合わせることで、関係する全てのデータに対して整合性を保ちながら変更することが可能となる。

ストアドプロシージャを使用する際の注意点は以下の通りです。

* データベース製品ごとに定められている構文規約と標準規格の互換性が低いため、コード資産としての再利用性が悪い（各DBMSごとに書き方が異なる）
* 業務の仕様変更に際して、外部のアプリケーションと共にストアドプロシージャの定義を変更する必要があるため、余計な手間や変更ミスによる障害を発生させる可能性がある

---

## プロシージャとファンクション

ストアドプロシージャは、DBMS内で動作するプログラムですが、実はファンクションとプロシージャの2種類があります。
それぞれの違いは以下になります。

* ファンクション
  * 戻り値がある
  * SELECT文やINSERT文など（つまりDML）の中で呼び出すことができる

* プロシージャ
  * 戻り値はありません
  * SELECT文では呼び出せない（CALL句で呼び出す）
  * 処理の中でトランザクション制御（COMMITやROLLBACK）を行うことが可能

これらの違いは一般的な話であり、厳密にはDBMSによって違いがあります。詳しく知りたい場合は使用しているDBMSのマニュアルを参照してください。
ファンクションについては、SQL標準でも色々と用意されています（trunc, truncate関数など）が、「CREATE FUNCTION」により自作することが可能です。

---

### ファンクションの例

ここでは、金額を受け取って消費税込みの金額を計算するファンクションを考えます。

以下はMySQLの例です。

```sql
delimiter //  -- 区切り文字変更

-- 関数の宣言
create function tax_include(price int) returns int
deterministic
begin
    -- 処理開始
    return truncate(price * 1.1, 0);
end
//

delimiter ;  -- 元に戻す
```

---

以下はPostgreSQLの例です。

```sql
--税込み金額を返すファンクション 
CREATE OR REPLACE FUNCTION tax_include(price integer) RETURNS integer
 LANGUAGE plpgsql
AS $function$
declare

begin
    return trunc(price * 1.1, 0);
end;
$function$;
```

使用する場合は以下のようになります。

```sql
-- 呼び出し
select tax_include(100);
```

---

### プロシージャの例

ここではcompanyテーブルのバックアップを作成する例を考えます。

以下はMySQLの例

```sql
delimiter //

create procedure create_company_backup()
begin
    DELETE FROM company_backup;
    INSERT INTO company_backup SELECT * FROM company;
end 
delimiter ;
```

---

以下はPostgreSQLの例

```sql
CREATE OR REPLACE PROCEDURE create_company_backup()
LANGUAGE plpgsql
AS $$
DECLARE
BEGIN
    DELETE FROM company_backup;
    INSERT INTO company_backup SELECT * FROM company;
END;
$$;
```

実行は以下のようにします。

```sql
-- プロシージャの呼び出し
call create_company_backup();
```

---

## トリガー

トリガーは引き金を意味する用語です。
DBMSにおけるトリガーとは、特定のテーブルに対して更新（insert, update, delete）が引き金になって実行されるプログラム（SQL文）のことです。

**トリガーを使用する場面**

状況として、商品テーブル（items）に対して更新が行われた際に、更新の履歴を残しておきたい場合を考えます。

この場合、更新（UPDATE）が行われたタイミングで、更新前のレコードを履歴用のテーブルに退避することで実現できます。

例えば、itemsテーブルが更新されたときに、items_bkテーブルに更新前のレコードを保存するには以下のようにします。

```sql
-- ファンクションの定義
-- items_bkにレコードを登録するファンクション
CREATE OR REPLACE FUNCTION items_update_trigger()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
BEGIN
    INSERT INTO items_bk(item_id, item_name, price, update_dt) 
        VALUES (OLD.item_id, OLD.item_name, OLD.price, now());
    RETURN NULL;
END;
$$;

-- トリガーの定義
-- itemsテーブルにUPDATEされた時に、更新前に上記のファンクションが動作させるようにする
CREATE TRIGGER item_bk_trigger BEFORE UPDATE ON items
FOR EACH ROW
EXECUTE PROCEDURE CREATE OR REPLACE FUNCTION items_update_trigger();
```

PostgreSQLの場合はトリガーを作成するときにまずファンクションを作成する必要があります。
トリガー作成の構文はDBMS製品によって異なるので、使用するDBMSのマニュアルを確認してください。

---

## シーケンス

シーケンスは連番を管理するための機能です。
一般的にテーブルの主キーには意味を持たない連番として「id」のようなカラムを持たせることが多いです。
シーケンスを使うことで連番のセットが容易になります。

シーケンスの構文

```sql
-- 単純なシーケンス作成の構文
CREATE SEQENCE <シーケンス名>;
```

PostgreSQLの場合、テーブル作成時に自動で連番が振られる型としてserial型があります。
serial型は内部的にはシーケンスが1つ自動で作成され、そのシーケンスによって連番が振られる仕組みになっています。

**DBMSごとの違い**

MySQLにはシーケンスの機能はありません。テーブル作成時に「AUTO_INCREMENT」のオプションを指定することで自動的に採番される機能はありますが、テーブルと独立して連番を管理する機能はありません。

他の主要なDBMS（Oralce, SQL Server, PostgreSQL, DB2）にはシーケンスの機能がありますが、連番の取得の方法など、細かい使用方法は製品によって異なりますので、詳しい使用方法はマニュアルを参照してください。

---

## トランザクション制御

ユーザーによる検索や更新などの一続きの手続きをトランザクションといいます。
DBMSは、複数のユーザーがデータを共有して同時に操作を行うことを前提としているため、トランザクションを制御する機能が備わっています。

トランザクションにはコミットとロールバックという2種類の操作があります。
コミットは「処理の確定」、ロールバックは「処理の破棄」を行います。

![picture 11](/images/d52fd694031e3633d1c915fe94805a92c591d8bf3fc4f5657c44b5acb5e0b25f.png)  

また、複数のトランザクションが並行して実行された時でも、アクセス制限（ロック）をかけることで、データの整合性が崩れないようにします。
アクセス制限（ロック）には「占有ロック」と「共有ロック」があります。

---

### 占有ロック

データベースを更新する時にかけるロックです。
他のユーザーはロックをかけたり、データを参照または更新したりすることはできません。

### 共有ロック

データを参照する時にかけるロックです。
他のユーザーは、共有ロックやデータを参照したりできます。
ただし、占有ロックをかけたり、データを更新することはできません。

トランザクション制御を行うとき、注意しなければならないことがあります。
**デッドロック**と呼ばれる状態です。
デッドロックとは複数のトランザクションがお互いにロック解除待ち状態となり、処理が停止してしまう状態です。

---

**デッドロックの例**

まず、トランザクションAがテーブルaを更新するためにロックを取得します

![picture 12](/images/92d6e1e6fed21092ed1d672be235101a8f43a8db63a1230060870d4e4fae7a0a.png)  

次にトランザクションBがテーブルbを更新するためにロックを取得します。
この段階でテーブルa、テーブルbの両方がロックされている状態です。

![picture 13](/images/105cc40e9b861952aaa4027cd9beab48a0858953623fdf24f532436668b754ad.png)  

---

この状態でトランザクションAがテーブルbを更新しようとしても、テーブルbはトランザクションBによってロックされているため、ロックを取得することはできません。
つまり「ロック解除待ち」となります。

![picture 14](/images/37a5bb390c508c2c25801bace511b23667b9af5d57b07a1c528f1c883b353dbf.png)  

さらに、トランザクションBがテーブルaを更新しようとしても、テーブルaはトランザクションAによってロックされているため、ロックを取得することはできません
つまりトランザクションBも「ロック解除待ち」となります

![picture 15](/images/8a8cf057462b966b69126341ba59fb708743808106fca335d94e7dc70ea73426.png)  

このような状態になると、どちらのトランザクションもずっとテーブルの「ロック解除待ち」の状態となります。
この状態がデッドロックと呼ばれる状態で、どちらのトランザクションも処理が進まなくなります。

---

## バックアップとリストア

大量のデータを扱うデータベースですが、その情報が何らかの原因で消えてしまうと大変なことになります。
DBMSにはハードディスクの故障や停電などの障害に備えて、バックアップを取る機能があります。

データのバックアップをする方法として以下の3種類について見ていきます。

* フルバックアップ
* 差分バックアップ
* 増分バックアップ

---

### フルバックアップ

一定期間毎に保存されている全データのバックアップを行う方法です
複製した情報がひとまとまりになっているため、復旧時に情報を集める必要がなく簡単です。
一方で、毎回全データをコピーするため、バックアップに時間がかかり、バックアップ先に十分な空き容量も必要となります。

![picture 16](/images/e5b0e06342e5159d3527618eb25269b26dbdf317b8cd362346e57d30b67579cf.png)  

---

### 差分バックアップ

フルバックアップ以降に変更されたデータのみバックアップを行います
復旧時にはフルバックアップと最新の差分バックアップが必要です。
フルバックアップに比べ、バックアップに時間がかからず、バックアップ先の容量も必要としません。

![picture 17](/images/534adaad88da155dd33959be40fee38949200c74a6a174874f2292a6bf76cefb.png)  

---

### 増分バックアップ

前回のバックアップ以降に変更されたデータのみバックアップを行います。
バックアップにかかる時間が一番短く、バックアップ先の容量も必要ありません
しかし、復旧時には全ての情報を集める必要があります。

![picture 18](/images/ffd7bb8ae8ce8162ed3ad1afa1f693fedb28c2906045051edf552a9b21699ab1.png)  


---

## リストア

障害が発生した時は、前述したバックアップファイルを使用して復旧作業（リストア）を行います。
差分バックアップと増分バックアップファイルを使用する場合は、先にフルバックアップファイルでリストアした後に、差分バックアップや増分バックアップ分を適用します。

しかし、それでもデータベースは最新の状態になってはいません。
復旧作業（リストア）を行っても「バックアップした時」までしか復旧できていないのです。
そのため、DBMSは「ジャーナルファイル」というログファイルを使用して復旧を行います。

更新後情報のログを使って障害直前の状態にまで復旧させる処理をロールフォワードといいます。
更新後情報ログのため、更新処理が完了した状態で復旧します。

![picture 19](/images/281087f7db8d6ffff1c4ab60479f329718e70a19821f5106a00b4201c1d50b85.png)  
