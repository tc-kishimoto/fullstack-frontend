# オブジェクト指向

---

## 概要

オブジェクト指向の基本を学びます。

クラスとインスタンスが何かを理解し、利用できるようにします。


---

## オブジェクト指向

オブジェクト指向は、プログラミングを効率よく行うための考え方です。

簡単に言うと、データと処理をまとめたものを「オブジェクト」として扱う考え方です。

オブジェクトを作るための枠組みとして「クラス」を作成します。

簡単なプログラムであれば、クラスを作成する必要はありません。

しかし、プログラムの規模が大きくなると、変数や関数が増えてきて管理が難しくなります。

クラスを作成することで、プログラムの再利用性や保守性を高めることができます。


---

## クラスとインスタンス
クラスは、簡単に言うと変数と関数をまとめたものです。

クラスは概念であり、実際に変数や関数を使用するには、クラスからオブジェクトと呼ばれる実体を作成します。

PHPではオブジェクトのことをインスタンスと呼びます。


---

クラスとインスタンスの使い方を例を見ながら学習していきます。

まずは以下のプログラムを確認してください。

このプログラムはクラスやインスタンスは使用しないプログラムです。


```php
<?php
// 1人目
$name1 = "佐藤";
$eScore1 = 75;
$mScore1 = 84;
dispScore($name1, $eScore1, $mScore1);

// 2人目
$name2 = "鈴木";
$eScore2 = 68;
$mScore2 = 70;
dispScore($name2, $eScore2, $mScore2);

// 成績表示の関数
function dispScore($name, $eScore, $mScore) {
    echo "{$name}さん<br>";
    echo "英語：{$eScore} 数学：{$mScore}<br>";
    $sum = $eScore + $mScore;
    $avg = $sum / 2;
    echo "合計：{$sum} 平均：{$avg}<br>";
} 
```

---

結果

```text
佐藤さん
英語：75 数学：84
合計：159 平均：79.5
鈴木さん
英語：68 数学：70
合計：138 平均：69
```

このプログラムは二人分のスコアを表示するプログラムです。
名前と、2科目分のスコアを設定し、関数の引数に渡すことでそれぞれのスコア、合計、平均を出力します。

プログラム自体は問題はなく動作します。

しかし、人数が増えるたびに変数が3つずつ増えるため、後々プログラムの管理が面倒になりそうなことが予想されます。

名前やスコアは関連したデータなので、まとめて管理することができると便利で使いやすくなります。

このように、複数のデータや処理を一纏めにして扱いたい場合には、クラスを使用します。


---

クラスの定義方法は以下になります。
プロパティ、コンストラクタ、メソッドについてはそれぞれ後で説明します。

```text
class クラス名
{
    プロパティ

    コンストラクタ

    メソッド
}
```

---

サンプルとしてUserクラスを定義して、先ほどと同じ結果になるプログラムを実装してみます。


```php
<?php
// クラス定義
class User 
{
    // プロパティ
    public $name = "";
    public $eScore = 0;
    public $mScore = 0;

    // メソッド
    function dispScore() {
        echo "{$this->name}さん<br>";
        echo "英語：{$this->eScore} 数学：{$this->mScore}<br>";
        $sum = $this->eScore + $this->mScore;
        $avg = $sum / 2;
        echo "合計：{$sum} 平均：{$avg}<br>";
    } 
}

// インスタンスの作成
$user1 = new User();
$user1->name = "佐藤";
$user1->eScore = 75;
$user1->mScore = 84;
$user1->dispScore();

// インスタンスの作成
$user2 = new User();
$user2->name = "鈴木";
$user2->eScore = 68;
$user2->mScore = 70;
$user2->dispScore();
```

---

結果

```text
佐藤さん
英語：75 数学：84
合計：159 平均：79.5
鈴木さん
英語：68 数学：70
合計：138 平均：69
```

クラスを使う場合も使わない場合も同じ結果を得ることができました。

クラスをもとに「new」というキーワードを使って作られた「user1」「user2」がそれぞれインスタンスになります。

今回の例ではソースコードの量はさほど変わりありませんが、佐藤さんの情報は「user1」、鈴木さんの情報は「user2」にまとまっているため、プログラムが管理しやすくなります。


クラスに定義された変数のことを「プロパティ」と呼びます。

クラスに定義された関数のことを「メソッド」と呼びます。

「プロパティ」と「メソッド」を合わせて「メンバ」と呼びます。

用語として覚えておきましょう。


---

## プロパティとメソッド

```php
<?php
class User 
{
    public $name = "";  // プロパティ

    // メソッド
    function dispScore() {
        // …
    } 
}
```

プロパティはインスタンスが持つ状態（データ）を表します。 

---

プロパティの宣言方法は以下になります。

アクセス修飾子は後半に解説します。

初期値は不要であれば省略可能です。

PHP7.4以降はデータ型を指定することも可能です。


```php
class クラス名 
{
    // プロパティ
    アクセス修飾子 プロパティ名 = 初期値;
    // 例
    public $name = "";  
}
```

---

メソッドはインスタンスが持つ振る舞い（処理）を表します。

基本的な定義方法は関数と同じです。

プロパティと同じくアクセス修飾子を指定できます。


```php
class クラス名
{
    // メソッド
    アクセス修飾子 function メソッド名() 
    {
        // …
     }
    // 例
    public function dispScore() 
    {
        // …
    } 
}
```

---

## コンストラクタ

Userクラスを利用する場合、インスタンスを作成した後、３つのプロパティに一つずつ値を設定しています。


```php
<?php
$user1 = new User();
$user1->name = "佐藤";  // ３つを毎回設定するのは面倒
$user1->eScore = 75;    // まとめて設定できないか？
$user1->mScore = 84;
$user1->dispScore();
```

しかし、毎回一つずつ設定するのは面倒です。一気に値を設定できることができれば楽です。

コンストラクタを使えば解決することができます。

コンストラクタとは、インスタンスを作成するときに呼ばれる特殊なメソッドです。


---

プロパティとメソッドの間に以下のようなコードを追加してみましょう。

コンストラクタはメソッド名が「__construct」と決まっています。


```php
<?php
class User {
    // プロパティ

    // コンストラクタ
    function __construct($name, $eScore, $mScore) {
        $this->name = $name;
        $this->eScore = $eScore;
        $this->mScore = $mScore;
    }
    // メソッド
}
```

---

また、引数を持つことができます。

Userクラスでは、３つのプロパティに値を設定したいので、引数を３つ持つことにします。

引数で受け取った値をプロパティに設定します。


```php
<?php
// クラス定義
class User 
{
    // プロパティ
    public $name = "";
    public $eScore = 0;
    public $mScore = 0;

    // コンストラクタ
    function __construct($name, $eScore, $mScore) {
        $this->name = $name;
        $this->eScore = $eScore;
        $this->mScore = $mScore;
    }

    // メソッド
    function dispScore() {
        echo "{$this->name}さん<br>";
        echo "英語：{$this->eScore} 数学：{$this->mScore}<br>";
        $sum = $this->eScore + $this->mScore;
        $avg = $sum / 2;
        echo "合計：{$sum} 平均：{$avg}<br>";
    } 
}

// $user1 = new User();
// $user1->name = "佐藤";
// $user1->eScore = 75;
// $user1->mScore = 84;
$user1 = new User("佐藤", 75, 84);
$user1->dispScore();

// $user2 = new User();
// $user2->name = "鈴木";
// $user2->eScore = 68;
// $user2->mScore = 70;
$user2 = new User("鈴木", 68, 70);
$user2->dispScore();
```

---

結果

```text
佐藤さん
英語：75 数学：84
合計：159 平均：79.5
鈴木さん
英語：68 数学：70
合計：138 平均：69
```

同じ結果が得られました。

一つ一つプロパティのセットする手間が省けた分、ソースコードはすっきりしました。

値を一つ一つ設定せずに、newする際に引数を渡すことで、ソースコードが簡潔になっています。


---

コンストラクタを作成した際の注意点としては、引数ありのコンストラクタを定義すると、newする際には必ず引数を渡してあげる必要があります。

以下のように、引数なしでインスタンスを作成しようとするとエラーになります。


```php
$user1 = new User();  // ⇐エラーになる
// $user1->name = "佐藤";
// $user1->eScore = 75;
// $user1->mScore = 84;
$user1 = new User("佐藤", 75, 84);
$user1->dispScore();
```

---

### コンストラクタを作るべきか

PHPでは、コンストラクタはクラス内に一つしか作成することができません。
（同名の関数を２つ以上定義することができない）  
引数ありのコンストラクタを作成すると、インスタンスの初期化が楽になって便利な反面、後からプロパティを追加してコンストラクタの引数の数を追加する必要が出てきたときに、修正範囲が大きくなってしまう場合があります。

コンストラクタを作成する際には、後々プロパティの追加の可能性を考慮して作成することが大事です。


---

### インスタンスの中身の確認

これまで画面に値を出力するときには主に「echo」をしようしてきましたが、クラスのインスタンスに対してechoを使用するとエラーになります。

インスタンスの中身を出力して確認したい場合は、配列と同様に「var_dump()関数」を使用します。


```php
$user1 = new User("佐藤", 75, 84);

echo $user1;      // エラーになる
var_dump($user2); // プロパティの名前、型、値などが確認できる
```

---

## アクセス修飾子

プロパティの変数名の前に「public」というキーワードがついています。

これはアクセス修飾子と呼ばれるもので、「プロパティやメソッドをどこまで公開するか」を設定するものです。


```php
<?php
class User {
    public $name = "";
    public $eScore = 0;
    public $mScore = 0;

    // …
}
```

---

アクセス修飾子は３種類あります。

* public：どこからでもアクセス可能
* protected：自クラスと継承先のクラスからアクセス可能
* private：自クラスからのみアクセス可能

となっています。

継承はこの単元では扱わないため、protectedはここでは省略します。

ここではpublicとprivateの違いを見ていきます。


---

### public

ここではプロパティのアクセス修飾子は「public」のため、クラスの外部からでも値を変更することができます。


```php
<?php
class User {
    public $name = "";
    public $eScore = 0;
    public $mScore = 0;

    // コンストラクタ
    function __construct($name, $eScore, $mScore) {
        $this->name = $name;
        $this->eScore = $eScore;
        $this->mScore = $mScore;
    }

    // メソッド
    function dispScore() {
        echo "{$this->name}さん<br>";
        echo "英語：{$this->eScore} 数学：{$this->mScore}<br>";
        $sum = $this->eScore + $this->mScore;
        $avg = $sum / 2;
        echo "合計：{$sum} 平均：{$avg}<br>";
    }
}

$user1 = new User("佐藤", 75, 84);
$user1->eScore = 80; // アクセス可能
$user1->dispScore();
```

---

結果

```text
佐藤さん
英語：80 数学：84
合計：164 平均：82
```

設定した値も正しく反映されているのが分かります。

---

### private
今度はpublicの部分を「private」に変更してみます。

privateにすると、外部のクラスからはアクセスできなくなります。


```php
<?php
class User {
    private $name = "";
    private $eScore = 0;
    private $mScore = 0;

    // …省略
}

$user1 = new User("佐藤", 75, 84);
$uesr1->eScore = 80; // エラーになる！
$user1->dispScore();
```

結果

```text
Fatal error: Uncaught Error: Class 'User' not found in 
/var/www/html/xxxx.php:2 Stack tract #0 {main} thrown in
/var/www/html/xxxon line 2
```

エラーが発生して結果が表示されません。


---

アクセス修飾子はプロパティだけでなく、メソッドにも適用することができます。

メソッドの場合、アクセス修飾子をつけなった場合は自動的にpublicの扱いになります。

クラスを作成するときにはメソッドやプロパティをどこまで公開するかによってアクセス修飾子を適切に定めるようにしましょう。


---

## カプセル化

先ほど、プロパティに対して適切なアクセス修飾子を付けるべきだと学習しました。

アクセス修飾子を設定する場合、privateにするとアクセスできなくなるので、publicにしておく方が良いと思った人もいるかもしれません。

しかし、実際にはプロパティはアクセス修飾子を「public」にするのは好ましくありません。

なぜでしょうか。例を使って確認します。


```php
<?php
class User {
    public $name = "";
    public $eScore = 0;
    public $mScore = 0;

    // コンストラクタ
    function __construct($name, $eScore, $mScore) {
        $this->name = $name;
        $this->eScore = $eScore;
        $this->mScore = $mScore;
    }

    // メソッド
    function dispScore() {
        echo "{$this->name}さん<br>";
        echo "英語：{$this->eScore} 数学：{$this->mScore}<br>";
        $sum = $this->eScore + $this->mScore;
        $avg = $sum / 2;
        echo "合計：{$sum} 平均：{$avg}<br>";
    }
}

$user1 = new User("佐藤", 75, 84);
$uesr1->eScore = 120;
$user1->dispScore();

```

---

結果

```text
佐藤さん
英語：120 数学：84
合計：204 平均：102
```

例では、スコアの値を120に設定しています。

特に問題はなさそうですが、仮にスコアの値が0～100の値しか取り得ない前提で他のプログラムが作成されているとどうなるでしょうか。
プログラムが想定外の動きをして、予期せぬ不具合が起きる可能性があります。


このように、本来設定されるべきでない値が設定させてしまわないように、プロパティのアクセス修飾子は「private」にします。

そして、プロパティに対する値の参照や値の設定は、専用のメソッドを作成し、メソッド経由で行うようにします。

このような手法を「カプセル化」と呼びます。


---

具体的なやり方を見ていきましょう。今回は「$eScore」を例に見ていきます。
まずはアクセス修飾子を「private」にします。

```php
<?php
class User {
    private $eScore = 0;
}

```

次に、プロパティの値を参照するためのメソッドを作成します。

このようなメソッドは「ゲッター」と呼ばれ、メソッド名を「get + プロパティ名」として作成するのが慣習となってます。

引数はなしで、戻り値はプロパティの値となります。


```php
<?php
class User {
    private $eScore = 0;
    function getEScore() {
        return $this->eScore;
    }
}
```

---

次はプロパティに値をセットするためのメソッドを作成します。

このようなメソッドは「セッター」と呼ばれ、メソッド名を「set + プロパティ名」として作成するのが習慣となっています。

処理は引数を受け取って、プロパティに値をセットします。


```php
<?php
class User {
    private $eScore = 0;

    // ...

    function getEScore() {
        return $this->eScore;
    }

    function setEScore($eScore) {
        $this->eScore = $eScore;
    }

    // ...
}
```

---

ゲッターとセッターを合わせて、「アクセッサ」や「アクセッサメソッド」と呼ばれます。

つまり、カプセル化とは、プロパティのアクセス修飾子を「private」にして、それに対するアクセッサメソッドを用意することだと言えます。


---

先ほどUserクラスでアクセッサメソッドを用意しましたが、問題点はまだ改善されていません。

値のセットをメソッド化したものの、セッターの引数に入れた値がそのままセットされる処理になっているので、どんな値でもセットできてしまいます。


```php
$user1 = new User("佐藤", 75, 84);
$uesr1->setEScore(120); // ⇒想定外の値もセットできる
$user1->dispScore();
```

これではアクセッサを用意した意味がありません。 

---

そこで中身を修正して、$eScoreが0以上、かつ100以下の場合は渡された値をそのままセットし、それ以外の場合は0をセットするようにします。


```php
<?php
class User {
    // ..

    function setEScore($eScore) {
        if ($eScore >= 0 && $eScre <= 100) {
            $this->eScore = $eScore;
        } else {
            $this->eScore = 0;
        }
    }

    // ..
}

```

これで不正な値はセットされなくなりました。

このように、値のセットや取得をメソッド化することで、細かい制御ができるという点がカプセル化のメリットです。

「値が30点以下だった場合はスコアを知られたくない」という場合には、ゲッターで処理を制御することで実現可能です。

カプセル化はオブジェクト指向において重要な概念の一つですので、クラスを作成するときには意識するようにしてください。


---

## メソッドのアクセス修飾子

クラスを作成するときには、プロパティのアクセス修飾子を「private」にし、アクセッサメソッドでプロパティへのアクセスを提供する（カプセル化する）のがよくあるクラス設計のパターンです。

ではメソッドのアクセス修飾子はどのようにするべきでしょうか？  

「メソッドは全てpublicにする」のは初心者にありがちです。

しかし、**自クラス内でのみ使用するメソッドに関しては、アクセス修飾子はprivateにしておくべきです。**  
アクセス修飾子がpublicになっていると、誰かがそのメソッドを利用している可能性があります。

クラス作成者の知らない内にメソッドが利用されていた場合、そのメソッドを修正した場合も影響範囲を特定するのが難しく、修正が困難になる場合があります。

後々の修正を楽にするためにも、外から呼ばれる可能性のないメソッドはprivateにしておきましょう。


---

## static

ここでは、クラスが持つプロパティやメソッドを学習します。

Userクラスが持つプロパティ、「`$name`」「`$eScore`」「`$mScore`」は、各ユーザーの名前やスコアの情報です。つまり、Userクラスのオブジェクトに紐づけられています。

ここで、今までのスコアの最大スコアを保持しておきたい場合、クラス全体のプロパティとして値を保持しておく必要があります。

その場合に使用するのが「static」というキーワードです。


---

使い方を見ていきましょう。まずはプロパティからです。

定義方法は、プロパティ名の前に「static」というキーワードを付けるだけです。

使用方法は、「クラス名::プロパティ名」でアクセスすることができます。


```php
<?php
class User {
    public static $maxScore = 0;

    // …
}

User::$maxScore = 200;
echo User::$maxScore;
```

結果

```text
200
```

---

次はメソッドです。定義方法や使用方法はプロパティの時と同じです。

クラス内からstaticプロパティにアクセスするには「self::プロパティ名」とします。これも合わせて覚えておいてください。


```php
<?php
class User {
    public static $maxScore = 0;
    
    // ...

    static function setMaxScore($eScore, $mScore) {
        if ($eScore + $mScore > self::$maxScore) {
            self::$maxScore = $eScore + $mScore;
        }
    }

    // ...
}

User::setMaxScore(80, 90);
echo User::$maxScore;
```

結果

```text
170
```

---

ちなみに、同じクラス内であっても、staticメソッドであるか、staticなしのメソッドであるかによって、どのメンバにアクセスできるかが異なります。

どこからどこに対してアクセス可能か押さえておきましょう。


* staticメソッドからのアクセス
  * staticなしのメソッド・プロパティ：×
  * staticメソッド・プロパティ：〇
* staticなしメソッドからのアクセス
  * staticなしのメソッド・プロパティ：〇
  * staticありのメソッド・プロパティ：〇

staticメソッドの中で、staticなしのメソッドを呼び出すことはできないと覚えておいてください。


---

## 定数

1度値を設定したらそのあと変更できない変数を「定数」と呼びます。

クラスに定数を定義する方法を見ていきましょう。


Userクラスに、スコアの合格点を保持します。これは、外部から変更されては困ります。また、クラス全体で共有すべき情報です。このような場合、クラス内に定数として保持します。

定数を定義するには「const」というキーワードを使用します。

定数名は、全て大文字で、「$」もつけません。

使用方法はstatcプロパティと同じです。


```php
<?php
class User {
    const PASSING_SCORE = 80;

    // ...
}

echo User::PASSING_SCORE; // ⇒ 80
```

---

定数は値を書き換えることはできませんので、代入をしようとするとエラーになります。

```php
<?php
class User {
    const PASSING_SCORE = 80;

    // ...
}

User::PASSING_SCORE = 90; // ⇒ エラー
echo User::PASSING_SCORE; // ⇒ 80
```

---

## 名前空間

複数人でプログラム開発を行なった際に、クラスの名前や関数の名前が重複してしまった場合どうすれば良いでしょうか。

通常、クラス名や関数名は重複できません。

しかし、既存の関数名やクラス名と同じ名前を使用したい場合もあります。

その問題を解決するのが名前空間です。

名前空間は直感的にはOSのフォルダのような概念で、名前空間が異なることで同じ名前の関数やクラスを定義することができます。


名前空間を定義するにはnamespaceというキーワードを使用します。

namespaceはプログラムの先頭に書きます。

別ファイルからそのクラスを利用する場合は、「use 名前空間\クラス名」を宣言します。


```php
<?php
namespace obj;

class User {
    // ...
}
```

---

別ファイルからの利用する場合

```php
<?php
use obj\User; // クラスを使用できるようになる

$user = new User();
```

ただし、別ファイルから利用する場合でも、同じ名前空間に存在するファイルであれば、useは省略することが可能です。


名前空間は階層を持つことも可能です。

その場合は\マーク(環境によってはバックスラッシュ)記号で階層を区切って表現します。

```php
<?php
namespace axiz\php;

class User {
    // クラス定義
}
```

---

## まとめ

* オブジェクト指向は、プログラミングを効率的に行う考え方。
* オブジェクトとは、データ（プロパティ）と処理（メソッド）をまとめたもの。
* オブジェクトの雛形のことをクラスと呼ぶ。
* クラス作成されたオブジェクトのことをPHPではインスタンスと呼ぶ。
* コンストラクトは、インスタンスが生成される時に呼ばれる特殊なメソッド。
* アクセス修飾子はプロパティやメソッドをどこまで公開するかを設定するもの。
* プロパティをprivateにして、メソッド経由でアクセスさせることにより、情報隠蔽を行うことをカプセル化と呼ぶ。
* メソッド・プロパティにstaticをつけるとクラスが保持するメソッド・プロパティになる。
* 定数は一度代入したら再代入することができない変数。





