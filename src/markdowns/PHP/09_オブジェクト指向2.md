# オブジェクト指向2

---

## 概要

オブジェクト指向について深掘りします。

継承を使って、オブジェクト指向をより有効活用する手法を学びます。

抽象クラス、インターフェースなどの、より抽象的な概念を学びます。


---

## 継承

オブジェクト指向では既存のクラスを拡張して、新しいクラスを作成することができます。

そのような仕組みを「継承」といいます。

継承を利用すると、コードを再利用しやすくなります。


---

継承を使うために、ベースとなるクラスを作成しておきます。

前回のオブジェクト指向の講義で使用したUserクラスを元にしていきます。


```php
<?php
class User 
{
    public $name = "";
    public $eScore = 0;
    public $mScore = 0;

    function __construct($name, $eScore, $mScore) 
    {
        $this->name = $name;
        $this->eScore = $eScore;
        $this->mScore = $mScore;
    }

    function dispScore() 
    {
        echo "{$this->name}さん<br>";
        echo "英語：{$this->eScore} 数学：{$this->mScore}<br>";
        $sum = $this->eScore + $this->mScore;
        $avg = $sum / 2;
        echo "合計：{$sum} 平均：{$avg}<br>";
    } 
}
```

---

ここで、同じファイル内にUserクラスを継承した新しいクラス（ExUserクラス）を作成します。

また、そのExUserのインスタンスを作成してメソッドを実行します。

ExUserクラス定義はどこに書いてもかまいませんが、Userクラスが参照できる状態で作成してください。

（名前空間が異なる場合はuseで指定。ファイルが異なる場合はrequireで読み込んでおく。）  

```php
<?php

// 継承したクラスの作成
class ExUser extends User 
{

}

$exUser = new ExUser('John', 80, 90);
$exUser->dispScore();
```

結果

```text
Johnさん
英語：80 数学：90
合計：170 平均：85
```

---

結果は、Userクラスのメソッドの内容で問題なく表示されることがわかります。

継承を行う場合、extendsというキーワードを使って、クラス定義の際に継承したいクラスを指定します。

この時、継承される側のクラス（今回だとUserクラス）のことを、親クラス、あるいはスーパークラスと呼びます。


継承を行う場合、extendsというキーワードを使って、クラス定義の際に継承したいクラスを指定します。

この時、継承される側のクラス（今回だとUserクラス）のことを、親クラス、あるいはスーパークラスと呼びます。

継承する側のクラス（今回だとExUserクラス）のことを子クラス、あるいはサブクラスと呼びます。


```php
<?php
class サブクラス extends スーパークラス 
{

}
```

---

サブクラスは、スーパークラスが持つプロパティやメソッド、コンストラクタなどをそのまま引き継ぐことができます。

そのため、ExUserクラス自身の中身は空ですが、Userクラスを同じプロパティを設定して、同じメソッドを使用することができます。


中身が空のままだとUserクラスと同じことしかできないので、プロパティやメソッドを追加してみます。


```php
<?php
class ExUser extends User 
{
    public $jScore;
    function dispJScore() 
    {
        echo "国語の点数は{$this->jScore}点です。";
    }
}

$exUser = new ExUser('John', 80, 90);
$exUser->jScore = 95;
$exUser->dispJScore();
```

---

結果

```text
国語の点数は95点です。
```

そのままプロパティをセットしてメソッドを呼び出します。
問題なく実行できることが確認できます。

このように、継承を利用すると、既存のクラスのプロパティやメソッドを引き継いだ上で新しくプロパティやメソッドを追加することができます。

うまく利用することで、ソースコードの量を減らして、効率よく開発を進めることができます。


---

## オーバーライド

ExUserクラスではjScoreというプロパティを追加しましたが、値をセットするにはインスタンス生成後にセットする必要がありました。

コンストラクタでjScoreもセットすることができれば楽です。

また、dispScoreメソッドでjScoreもセットすることができれば良さそうです。

そのためには、コンストラクタやdispScoreメソッドの処理を上書きする必要があります。


実は、クラスを継承した際には、既存のメソッドを再定義して処理の定義を上書きすることが可能です。

この、サブクラスによるメソッド定義の上書きのことをオーバーライドと呼びます。


---

コンストラクタとdispScoreメソッドをオーバーライドします。

コンストラクタを追加し、dispScoreメソッドをオーバーライドします。


```php
class ExUser extends User 
{
    public $jScore;

    function __construct($name, $eScore, $mScore, $jScore)
    {
        parent::__construct($name, $eScore, $mScore);
        $this->jScore = $jScore;
    }

    function dispScore() 
    {
        echo "{$this->name}さん<br>";
        echo "英語：{$this->eScore} 数学：{$this->mScore} 国語：{$this->jScore}<br>" ;
        $sum = $this->eScore + $this->mScore + $this->jScore;
        $avg = $sum / 3;
        echo "合計：{$sum} 平均：{$avg}<br>";
    } 
}
```

---

インスタンスを作成してメソッドを呼び出してみます。

コンストラクタで引数を追加したので、インスタンス作成時に引数を４つ設定します。

```php
<?php
$exUser = new ExUser('John', 80, 90, 95);
$exUser->dispScore();
```

結果

```text
Johnさん
英語：80 数学：90 国語：95
合計：265 平均：88.333333333333
```

オーバーライドしたメソッドが呼び出されました。

---

コンストラクタを追加した際に、「parent::」というキーワードが出てきました。

このキーワードを使うことで、親クラスのプロパティやメソッドにアクセスすることができます。

ここでは３つのプロパティへの値のセットを親クラスのコンストラクタに任せています。


```text
parent::__construct($name, $eScore, $mScore);
```

### 継承の欠点

継承は使う場面によっては便利ですが、制約もあります。

それは単一継承しかできないという点です。

複数のクラスを継承することを多重継承と呼びますが、PHPでは多重継承は禁止されています。

継承を行うときには、他のクラスを継承する可能性がないかどうかを検討する必要があります。


---

## 抽象クラス

クラスを定義する際に、インスタンスを作成することができない、継承を前提としたクラスを定義することができます。

抽象クラスでは、抽象メソッドと呼ばれる処理のないメソッドを定義することができ、サブクラスでは抽象メソッドをオーバーライドします。


---

以下は抽象クラスのサンプルです。


```php
<?php
abstract class Employee
{
    public $name;
    public $age;
    abstract function work();
}
```

抽象クラスは宣言時にabstractというキーワードを指定します。

また、処理のないメソッド（抽象メソッド）を定義する場合も、関数宣言時にabstractキーワードを指定します。

抽象メソッドでは、{}(中括弧)は書かずに、;(セミコロン)で定義を終了します。

抽象クラスでは抽象メソッドが定義できますが、それ以外の通常のメソッドやプロパティ、コンストラクタも定義可能です。


---

抽象クラスを継承したクラスを作成します。


```php
<?php
// Employeeクラス（具象クラス）の定義
class Sales extends Employee 
{
    function work()
    {
        echo '営業に行く<br>';
    }
}
```

抽象クラスを継承した通常のクラスのことを、具象クラスと呼ぶことがあります。また、抽象メソッドではない通常のメソッドのことを具象メソッドと呼ぶことがあります。


継承の仕方は、通常のクラスを継承する場合と何も変わりませんが、親クラスで抽象メソッドであったworkメソッドをオーバーライドしなければエラーになるという点が抽象クラスを継承する場合の特徴です。


---

試しにSalesクラスでworkメソッドをコメントアウトして実行してみると下記のようにエラーが出ます。

```text
Fatal error: Class Sales contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (Employee::work) in ...
```

継承が出来たらあとは具象クラスのインスタンスを作成すればメソッドを呼び出すことができます。

抽象クラスであるEmployeeクラスでインスタンスを作成した場合はエラーになるので注意してください。


```php
<?php
$employee = new Sales();
$employee->work();
```

継承が理解できていれば、抽象クラスの仕組みを理解するのはそれほど難しくありません。

しかし、今回のサンプルでは抽象クラスを使うことの利点は感じにくかったかもしれません。

実は抽象クラスは複数人でプログラムを開発する際に大きな意味を持ちます。

継承でオーバーライドを強制することにより、処理の実装漏れや、メソッド名のスペルミスを防ぐことができるようになります。


---

## 抽象クラスの活用

ここからは抽象クラスを活用する方法についてみていきます。

まずはEmployeeクラスにコンストラクタを定義してプロパティの値をセットしやすくしておきます。


次にEmployeeクラスに新しく具象メソッドを定義します。

具象メソッドの中で抽象メソッドを呼び出すことができることも知っておきましょう。


```php
abstract class Employee
{
    public $name;
    public $age;
    
    // 抽象メソッド
    abstract function work();

    // コンストラクタ
    function __construct($name, $age)
    {
        $this->name = $name;
        $this->age = $age;
    }

    // 具象メソッド
    function hardWork()
    {
        for($i = 0; $i < 3; $i++) {
            $this->work();
        }
    }
}
```

---

Employeeクラスを継承した新しいクラスも作成します。

ここではプログラマークラスを作成します。


```php
class Programmer extends Employee
{
    function work()
    {
        echo '開発する<br>';
    }
}
```

---

続いて、メソッドではない通常の関数を追加します。
ここでは、引数でEmployeeのインスタンスを受け取り、ageのプロパティの値によって処理を呼び分けます。

最後にそれぞれのインスタンスを作成して、関数を呼び出す処理を追加します。


```php
function order(Employee $employee) {
    if($employee->age >= 20 && $employee->age < 40) {
        $employee->hardWork();
    } else {
        $employee->work();
    }
}

$sales = new Sales('営業マン', 43);
$programmer = new Programmer('PHPプログラマー', 35);
order($sales);
order($programmer);
```

結果

```text
営業に行く
開発する
開発する
開発する
```

---

ポイントは、order関数の引数がEmployeeになっているにも関わらず、メソッドの処理内容はインスタンスに依存している点です。

それぞれのクラスでオーバーライドした処理が呼ばれています。

このような仕組みをポリモーフィズムと呼びます。


ポリモーフィズムの良い点は、メソッドの呼び出し元の処理を変更することなく機能の拡張ができる点です。

今回のサンプルでいえば、Employeeクラスを継承した新しいクラスを作成したとしても、orderメソッドは一切変更することなく追加したクラスのメソッドを呼び出すことが可能です。


---

## is-a関係とhas-a関係

継承はソースコードを共通化できる便利な機能ですが、実際のところ継承が使える場面は限られています。

継承が成り立つかどうかにおいては、継承関係を持つクラスどうしてis-a関係が成り立つかどうかが一つのポイントになります。

is-a関係が成り立つかどうかとは、継承関係にあるクラスどうして、「A is a B（AはBである）」が成り立つかどうかとうい考え方です。

一般には、 A is a B が成り立つ時、Aをサブクラス、Bをスーパークラスとした継承関係が成り立ちます。


---

### is-a関係の例

* A is a B → AはBである

* 人間 is a 生き物 → 人間は生き物である → ○

* 車 is a 乗り物 → 車は乗り物である → ○

* テレビ is a 家電 → テレビは家電である → ○

* パソコン is a テレビ → パソコンはテレビである → ✖️

パソコンとテレビは、どちらも画面（モニター）を保持し、画面に表示する機能を持ちます。

そのため、テレビというクラスを継承してパソコンというクラスを作成することがプログラミング上可能となりますが、継承関係としては不適切なプログラムと考えられます。


---

is-a関係とは別に、has-a関係と呼ばれる概念もあります。

「A has a B（AはBを保持している）」という考え方です。

これは、Aというクラスが、Bというクラスのインスタンスをプロパティとして保持している場合に使われる用語です。

例えば、パソコンはメインメモリやCPUといった部品を持っています。

パソコンというクラスが、メインメモリやCPUといったクラスのインスタンスをプロパティとして保持している場合に、has-a関係が成り立っていることになります。


---

## インターフェース

インターフェースは、クラスをより抽象化した概念です。

パソコンとテレビのように、is-a関係が成り立たないが、「画面を保持している」という共通の概念で同一視した（ポリモーフィズムを活用したい）場合もあります。

また、ポリモーフィズムをうまく活用したプログラムを作成したい場合、多重継承ができないのは大きな制約になります。

この２つの問題を解決できるのがインターフェースです。


インターフェースには以下の特徴があります。

* インスタンスは作成できない（抽象クラスと同様）
* メソッドは抽象メソッドのみ定義できる
* プロパティは定数のみ定義できる
* インターフェースの定義では「class」ではなく「interface」キーワードを利用する
* インターフェースの利用は継承ではなく「実装」と呼び、「inplements」キーワードを利用する

---

インターフェースの定義方法はクラスの定義方法に似ていますが、「class」の代わりに「interface」を使用します。

```php
interface インターフェース名 
{
  // 定数・抽象メソッドの定義
}
```

以下はインターフェースの例です。

開閉可能なものを同一視するためのインターフェースで、openとcloseという２つの抽象メソッドが定義されています。


```php
interface openable
{
    function open();
    function close();
}
```

---

以下はインターフェースを実装したクラスです。

implementsというキーワードを使って対象のインターフェースを指定し、抽象メソッドをオーバーライドします。


```php
class Door implements openable
{
    public function open()
    {
        echo 'ドアを開く';
    }
    public function close()
    {
        echo 'ドアを閉じる';
    }
}
```

---

インターフェースの便利なところは、継承と違って、複数のインターフェースを同時に実装できる点です。

また、クラスを継承しながらインターフェースを実装することも可能です。

このような点から、インターフェースはクラスの継承に比べてポリモーフィズムの利点を受けやすくなります。


```php
class A extends B implements C, D, E
{
  //  クラスの定義
}
```

現時点ではインターフェースがどのような場面で活躍するのかイメージするのは難しいかもしれません。

正直なところ、1人で小規模な開発を行っている間はインターフェースのメリットはほとんどありません。

複数名で大規模な開発を行う場合に、インターフェースを活用することで、クラス間の繋がりを疎結合に保ち、プログラムの柔軟性を高めることができます。


---

## まとめ

* 既存のクラスを拡張して新しいクラスを作成することを継承と呼ぶ
* 継承される側のクラスをスーパークラス（親クラス）、継承したクラスをサブクラス（子クラス）と呼ぶ
* スーパークラスのメソッドをサブクラスで再定義することをメソッドのオーバーライドと呼ぶ
* PHPでは複数のクラスを同時に継承（多重継承）することはできない。
* 継承はis-a関係が成り立つクラス同士の場合に行う
* 継承されることを前提とした、インスタンスの作成できないクラスのことを抽象クラスと呼ぶ
* 抽象クラスでは抽象メソッド（処理のないメソッド）を作成することができる



