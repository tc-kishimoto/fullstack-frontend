# 関数

---

## 関数とは

関数とは、一言でいうと**まとまった処理に名前を付けたもの**です。
配列を学習した際、var_dump()、print_r()、sort()、range()などの関数を使用しました。

今までに紹介してきたもの以外にも、PHPにはすでに用意されている関数が多数存在します。（ライブラリと呼んだりします）これらをうまく活用することで、効率よく開発を進めることができます。

また、関数は自分で新しく作成することもできます。似たような処理を関数にまとめることで、さらに効率のより開発が可能になります。


---

## 関数に必要な用語

関数について学ぶ前に、関数と関連する用語をまとめておきます。

* 引数（ひきすう）  
  * 関数に受け渡す値のことです。
  * 関数によって引数がない場合もあれば、複数ある場合もありもあります。

* 戻り値（返り値）  
  * 関数が戻す値のことです。
  * 関数によってない場合もあります。
  * 必ず１つの値を返します。

* 関数を呼び出す
  * 関数の処理を実行することを「関数を呼び出す」と表現します。

---

関数という言葉は数学の分野で聞いたことがあるかと思います。

数学では１次関数、２次関数、三角関数などがあります。

数学の関数は一言で言えば「対応関係」です。

y = axなどの関数があったとき、xの値が決まればそれによってyの値が決まるという対応関係です。

プログラミングの関数も、引数の値によって処理結果が決まるという対応関係と捉えることもできます。


---

## 様々な関数

自分で関数を作成する前に、まずはPHPで既に用意されている関数を見ていきましょう。

一番最初の実行したPHPのプログラムを覚えていますか？  
phpinfo()は、インストールされているPHPの様々な情報を出力する関数です。


```php
<?php
phpinfo();
```

配列に関する関数は配列の単元で紹介しました。

PHPでは他にも数値に関数や文字列に関する関数なども多く用意されています。

ここではその一部を紹介します。


---

## 数値に関連した関数

小数点を切り上げ、切り捨て、四捨五入するなどの関数が用意されています。

また、指定範囲内のランダムな数を返す関数もあります。


```php
<?php
echo ceil(11.2),  '<br>'; // 切り上げ
echo floor(15.9), '<br>'; // 切り捨て
echo round(29.6), '<br>'; // 四捨五入
echo rand(1, 10), '<br>'; // ランダム
```

結果

```text
12
15
30
6
```

---

## 文字列に関連した関数

文字数の取得、大文字に変換、文字列置換、文字列切り取りなどの関数が用意されています。

```php
<?php
echo strlen("abcde"), '<br>'; // 文字数
echo mb_strtoupper("abcde"), '<br>'; // 大文字に変換
// 置換
echo mb_ereg_replace("abc", "xyz", "abcde"), '<br>'; 
echo mb_substr("abcde", 1, 2), '<br>'; // 切り取り
```

結果

```text
5
ABCDE
xyzde
bc
```

---

## 条件式でよく使用される関数

変数や配列に値が格納されているかどうかや、値が空かどうかを確認するのに使用される関数が用意されています。

isset()関数, empty()関数, is_null()関数などがあります。


```php
<?php
$a;
// 変数に値がセットされているかどうかをtrue, falseで返す
if(isset($a)) {
    echo $a;
} else {
    echo '値がない';
}
```

結果

```text
値がない
```

数値に関する関数や、文字列に関する関数を見てきましたが、PHPでは、ほかにも様々な関数が用意されています。

PHP公式マニュアル等を見ながら、様々な関数を使えるようにしていきましょう。


---

## 関数の定義

次は自分で関数を作成する方法を見ていきましょう。

関数の定義方法は以下のようになります。

```text
function 関数名 (引数) 
{
    処理
    return 戻り値;
}
```

引数と戻り値は必須ではありません。必要に応じて追加していきます。


---

まずは簡単な例を見ていきましょう。


```php
<?php
function greet() 
{
    echo "Hello";
}
```

Helloと表示するだけの簡単な関数です。

これで関数自体は問題なく、エラーにはなりません。

しかし、このプログラムを実行しても何も表示されません。


---

関数は定義しただけでは実行されません。

実行するには、関数を呼び出す作業が必要です。

では、実際に関数を呼び出してみましょう。


```php
<?php
function greet() 
{
    echo "Hello";
}
greet(); // 関数呼び出し
```

結果

```text
Hello
```

関数を呼び出すには、そのまま関数名を記述します。()も書く必要があります。

ちゃんと画面に表示されました。

これだけでは味気ないので、機能を追加していきましょう。


---

## 引数

次は、関数に名前を渡して、「Hello 〇〇 !」と表示させるようにしましょう。

そのためには、「引数」と呼ばれるものを使用します。

引数は、関数名の後の()の中に記述し、関数の中で使用することができます。


```php
<?php
function greet($name) 
{
    echo "Hello, {$name}!";
}
greet("John"); // 関数呼び出し
```

結果

```text
Hello, John
```

期待した結果が表示出来ていることが確認できます。

---

ちなみに、引数は一つだけではなく、複数指定することができます。


```php
<?php
function greet($name1, $name2) 
{
    echo "Hello, {$name1} and {$name2}";
}
greet("Alis", "Bob"); // 関数呼び出し
```

結果

```text
Hello, Alis and Bob
```

---

また、引数には初期値を設定することもできます。

その場合、関数呼び出し時に引数を指定しない場合には初期値が使用されます。


```php
<?php
function greet($name = "Chris") 
{
    echo "Hello, {$name}!";
}
greet(); // 関数呼び出し
```

結果

```text
Hello, Chris!
```

---

引数で渡した値を関数の中で上書きした場合、どのような動きになるでしょうか。

結果を予想してから実行してみましょう。


```php
<?php
function greet($name) 
{
    $name = "bbb";
    echo $name; echo "<br>";
}
$name = "aaa";
echo $name, "<br>";
greet($name); // 関数呼び出し
echo $name, "<br>";
```

結果

```text
aaa
bbb
aaa
```

---

実は引数に値を渡すときには、値がコピーされて渡されています。

そのため関数内で引数の値を変更しても、呼び出し元には何の影響も与えません。

このような引数の渡し方を「値渡し」といいます。


では関数内で上書きした値を呼び出し元にも反映させる方法はないでしょうか。

実はそのような方法もあります。


---

先ほどのプログラムの引数に「&」を付けてみましょう。


```php
<?php
function greet(&$name) 
{
    $name = "bbb";
    echo $name; echo "<br>";
}
$name = "aaa";
echo $name, "<br>";
greet($name); // 関数呼び出し
echo $name, "<br>";
```

結果

```text
aaa
bbb
bbb
```

値が書き換わっているのが確認できます。

このような値の渡し方を「参照渡し」といいます。

使用する場面はそう多くはありませんが、このような使い方もできると覚えておきましょう。


---

次は戻り値についてみていきましょう。

戻り値は、関数の呼び出し元に返される値のことです。

今まで、関数の中でechoを使用して文字列を出力していました。


```php
<?php
function greet($name) 
{
    echo "Hello, {$name}!";
}
greet("John"); // 関数呼び出し
```

次は、戻り値で文字列を返し手上げて、呼び出し元で出力する処理に書き換えてみます。


---

もともとの処理はコメントアウトしておきます。

そして、戻り値を返すときには「return」を使用します。

関数の中身は以下のようになります。


```php
<?php
function greet($name) 
{
    // echo "Hello, {$name}!";
    return "Hello, {$name}!";
}
greet("John"); // 関数呼び出し
```

しかし、echoの処理がなくなったので、このままでは出力されません。


---

関数を呼び出している箇所で、戻り値を出力してあげる処理を追加してあげましょう。


```php
<?php
function greet($name) 
{
    // echo "Hello, {$name}!";
    return "Hello, {$name}!";
}
echo greet("John"); // 関数呼び出し
```

結果

```text
Hello, John!
```

ちゃんと出力されました。

これで戻り値を出力していることが理解できたでしょうか。


---

## 変数のスコープ

スコープとは、有効範囲のことです。

関数を使用するときには、変数のスコープに注意する必要があります。


具体例でみていきましょう。

以下のプログラムを実行してみましょう。echo で「100」と表示されるでしょうか？  

```php
<?php
function test() 
{
    $num = 100;
}
test();
echo $num;  // 100が表示される？
```

結果

```text
Notice: Undefined variable: num in /var/www/html/scope.php on line 6
```

結果は、表示されません。$numという変数が定義されていないと警告が表示されてしまいました。

これはどういう意味でしょうか。


---

実は、関数の中で定義された変数は、その関数の中でしか有効ではありません。

関数内で定義された変数のことを「ローカル変数」といいます。

ローカル変数のスコープは、「変数が定義された関数内」ということを覚えておきましょう。

引数もローカル変数と同じ扱いです。


```php
<?php
function test() 
{
    // test関数の中でしか使えない！
    $num = 100;
}
test();
echo $num;  // 参照できない！
```

---

次は逆も見ていきます。

つまり、関数の外で定義された変数が関数内で使用できるかどうかです。


```php
<?php
function test() 
{
    echo $num; // 参照できる？
}
$num = 100; 
test();
```

結果はこちらもエラーになりました。

関数の外で宣言された変数を関数内で使用することはできません。


```php
Notice: Undefined variable: num in /var/www/html/scope2.php on line 3
```

関数の外で宣言された変数は「グローバル変数」といいます。

---

まとめると

* グローバル変数のスコープは「関数の外」。
* ローカル変数のスコープは「それを定義した関数内」。
* ローカル変数とグローバル変数は共有はできない。

となります。

```php
<?php
function test() 
{
    $num_l = 100; // ローカル変数
}
$num_g = 100;  // グローバル変数
```

---

グローバル変数とローカル変数はスコープが異なるため、基本的に値を共有できませんが、共有するための仕組みもあります。

「global」というキーワードを使用すると、それが可能になります。


```php
<?php
function test() 
{
    global $num;
    echo $num; echo "<br>";
    $num++; 
}
$num = 100;
test();
echo $num;
```

結果

```text
100
101
```

「global」キーワードを使用すると、スコープを超えて値のやり取りができるため便利です。しかし、変数名の変更がしにくくなるなど、バグが発生しやすくなります。

関数との値のやり取りは、出来る限り「引数」や「戻り値」を使うようにしましょう。


---

次に、静的変数というものを見ていきます。
まずは以下のプログラムを実行してみます。

結果を予想してから実行してみましょう。


```php
<?php
function add($num) 
{
    $sum = 0;
    $sum += $num; 
    echo $sum; echo "<br>";
}
add(1); // 1を加算
add(2); // 2を加算
add(3); // 3を加算
```

結果

```text
1
2
3
```

さほど難しくはなかったと思います。

毎回$sumを0で初期化しているので、引数に渡された値がそのまま表示される結果となりました。


---

では次にstaticというキーワードを付けて実行してみます。

```php
<?php
function add($num) 
{
    static $sum = 0;
    $sum += $num; 
    echo $sum; echo "<br>";
}
add(1); // 1を加算
add(2); // 2を加算
add(3); // 3を加算
```

結果が変わりました。

saticを付けた場合、$sumの値が保持されている動きになっているのが確認できます。


```text
1
3
6
```

このように、関数の中の変数にstaticを付けておくと、最初の1回のみ実行され、その後プログラムが終了するまで保持される仕組みになっています。

staticキーワードがついた変数のことを「静的変数」といいます。


---

## 型の指定

関数の引数と戻り値にはデータ型を指定することもできます。

型を指定することで、プログラムの記述ミスや不具合を減らすことができ、プログラムの安全性を高めることができます。

型を指定する場合は以下のようにします。


```text
function 関数名(データ型 変数名, …): 戻り値の型
{
    // 処理
}
```

---

以下は型を指定した場合のプログラムです。


```php
<?php
function add(int $a, int $b): int
{
return $a + $b;
}
echo add(1, 2), '<br>';
echo add(3, 4), '<br>';
```

結果

```text
3
7
```

引数と戻り値でintを指定しています。

引数と戻り値は異なる型を指定しても問題ありません。


---

データ型を指定することで安全性が高まると述べましたが、実は、引数に値を渡す時、異なる型を渡しても正常に動作します。

以下の例では、intではなく文字列で数値を指定していますが、正常に実行されます。


```php
<?php
function add(int $a, int $b): int
{
    return $a + $b;
}
echo add('1', '2'), '<br>';
```

結果

```text
3
```

---

異なるデータ型の引数が渡された場合にエラーで処理を停止したい場合には「declare(strict_types=1);」  
という宣言を追加すると、エラーとなって処理が実行されなくなります。


```php
<?php
declare(strict_types=1);
function add(int $a, int $b): int
{
    return $a + $b;
}
echo add('1', '2'), '<br>';
```

結果

```text
Fatal error: Uncaught TypeError: Argument 1 passed to add() must be of the type int, string given, …
```

---

処理の内容によっては引数や戻り値でnullを許容したい場合もあります。試しにreturnでnullを返す処理を追加して、nullを返す処理を通るように関数を呼び出してみます。

すると結果はエラーになります。


```php
<?php
declare(strict_types=1);
function add(int $a, int $b): int
{
    if ($a > 0 && $b > 0) {
        return $a + $b;
    } else {
        return null;
    }
}
echo add(1, -2), '<br>';
```

```text
Fatal error: Uncaught TypeError: Return value of add() must be of the type int, null returned
```

---

nullを許可したい場合は、データ型の前に?マークをつける必要があります。

引数の場合も同様です。


```php
<?php
declare(strict_types=1);
function add(int $a, int $b): ?int
{
    if ($a > 0 && $b > 0) {
        return $a + $b;
    } else {
        return null;
    }
}
echo add(1, -2), '<br>';
```

---

## 再起呼び出し

関数の処理の中で自分自身の関数を呼び出すことを「再起呼び出し」と言います。

以下のプログラムは引数の値が1000を超えるまで2乗していくプログラムです。


```php
<?php
function add(int $num)
{
    $num **= 2;
    if($num < 1000) {
        return add($num);
    } else {
        return $num;
    }
}
echo add(5), '<br>';
```

再起呼び出しの処理が行われる場面はそれほど多くはありませんが、処理によってはループを使うよりもスッキリ書くことができます。

ただし、処理が終わる条件を間違えると関数の呼び出しが終わらず、無限ループになってしまう可能性があるので注意が必要です。


---

## 外部ファイルの読み込み

プログラムの規模が大きくなってくると、一つのファイルでプログラムを管理するのは難しくなってきます。

その場合、役割によってファイルを分けて、そのファイルを読み込んで使用するのが一般的です。


外部ファイルを読み込む方法は4つあります。

* require
  * エラーが出た場合は処理終了。
* include
  * エラーが出ても警告を発生させて、処理は続行する。
* require_once
  * ファイルが読み込まれているかチェックし、読み込まれていたらスキップする。
  * エラーが出たら処理終了。
* include_once
  * ファイルが読み込まれているかチェックし、読み込まれていたらスキップする。
  * エラーが出ても処理は続行。

---

多くの場合、PHPのみが書かれたファイルを読み込む場合はrequire_once、Webページに表示されるコンテンツの一部を取り込みたい場合はinclude、とするのが一般的です。


例を見てみましょう。

add.phpが、読み込まれる側のファイルです。引数で渡された値を加算する関数が定義されています。

adduse.phpが、add.phpを読み込む処理になっています。

他の３つも使用方法は同じです。


```php
<?php
function add($a , $b) {
    return ($a + $b);
}
```

```php
<?php
require(__DIR__.'/add.php');
echo add(1, 2);
```

---

## マジック定数

requireの引数の中で「`__DIR__`」というキーワードが出てきました。

これはマジック定数と呼ばれる、PHPの中であらかじめ定義されている定数の一つで、ファイルが存在するディレクトリのパスを返します。

定数は、再代入することができない変数です。


そのほかのマジック定数については公式マニュアルを参照ください。

https://www.php.net/manual/ja/language.constants.predefined.php

---

## 無名関数

テキストの最初に、関数の説明として「処理をまとめて名前をつけたもの」と説明しました。

しかし、実は関数は関数名をつけずに作成することも可能になっています。

このような関数のことを無名関数と呼びます。

無名関数はクロージャとも呼ばれます。


---

無名関数はその名の通し、関数名が存在しません。

定義するときにはfunctionキーワードの後にそのまま引数を定義し、中の処理を定義します。

使用する際には変数に代入し、その変数から関数を使用します。


```php
<?php
// 無名関数
$ad = function($a, $b) {
    return $a + $b;
};
echo $ad(11, 22);
```

結果

```text
33
```

無名関数は一見すると使い所があまりなさそうと感じるかもしれませんが、この後に解説するコールバック関数などでよく使用されます。


---

## コールバック関数

一部の関数には、引数に他の関数を受け取ることができる関数があります。

関数の引数として受け渡す関数のことをコールバック関数と呼び、callable型で表現されます。

ここでは配列操作の関数で、コールバック関数を引数に持つ関数を紹介します。


---

### 全ての要素を2倍にする

配列の各要素を２倍にしたい場合を考えます。

今までの知識で実現するなら、for文でループしながら各要素を倍にして再代入する方法が考えられます。


```php
<?php
// 全ての要素を2倍にする
$nums = [1, 2, 3, 4, 5];
for($i = 0; $i < count($nums); $i++) {
    $nums[$i] = $nums[$i] * 2;
}
print_r($nums);
```

結果

```text
Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10
```

---

### array_map()関数

配列の各要素を2倍にする処理の別解として、array_map関数を使用する方法があります。

array_map()関数は、第一引数にコールバック関数、第二引数に配列を受け取ります。

コールバック関数では無名関数を直接定義していますが、変数に代入しておいて、その変数を引数に渡すことも可能です。


```php
<?php
$array = [1, 2, 3, 4, 5];
$newArray = array_map(function($v) {
    return $v * 2;
}, $array);
print_r($newArray);
```

結果

```text
Array ( [0] => 2 [1] => 4 [2] => 6 [3] => 8 [4] => 10
```

第二引数で受け取った配列の各要素に対して、第一引数のコールバック関数の処理を適用し、その結果を配列として取得する返す関数です。

コールバック関数は事前の関数定義が不要でその場で処理定義することができます。引数の「$v」には配列の各要素が代入され、要素数分処理が実行されます。


---

### 配列から特定の条件を満たす要素のみ抽出した配列を取得

scoresという配列から、80以上の要素のみを抽出した配列を作りたい場合を考えます。

今までの知識で考えると、以下のようなプログラムで実現できます。


```php
<?php
$scores = [85, 70, 69, 82, 94, 55, 64, 85];
$highScores = [];
foreach($scores as $score) {
    if ($score >= 80) {
        $highScores[] = $score;
    }
}
print_r($highScores);
```

結果

```text
Array ( [0] => 85 [1] => 82 [2] => 94 [3] => 85 )
```

---

### array_filter()関数

同様の処理を、array_filter()関数を使うと簡単に実現できます。

第一引数で対象となる関数と、第二引数でコールバック関数を受け取ります。コールバック関数では、戻り値がbooleanとなる処理を定義します。

コールバック関数でtrueに要素だけを持つ新しい配列を返します。


```php
<?php
$scores = [85, 70, 69, 82, 94, 55, 64, 85];
$highScores = array_filter($scores, function($v) {
    return $v >= 80;
});
print_r($highScores);
```

```text
Array ( [0] => 85 [1] => 82 [2] => 94 [3] => 85 )
```

コールバック関数は慣れるまではイメージしにくく感じるかもしれませんが、配列の各要素に対して特定の処理を行いたい場合など、状況によってはソースコードが読みやすくなることもあります。


---

## まとめ

* 関数とは処理をまとめたもの
* PHP標準で多くの関数が用意されており、自分で作成することもできる
* 関数は引数を受け取ることができる
* 関数は戻り値を返すことができる
* 変数にはスコープがあり、関数内で宣言された変数は関数内でのみ有効
* 引数には型を指定することができる
* かんすうのなかで自分自身の関数を呼び出すことを再起呼び出しという
* PHPでは外部ファイルを呼び出す方法が4つある
* PHPにはあらかじめ用意されているマジック定数がある
* 関数名がない関数のことを無名関数と呼ぶ
* 関数を引数に受け取ることができる関数がある
* 引数に渡される関数のことをコールバック関数と呼ぶ
